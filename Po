-- Aimbot (Silent Aim) + WindUI controls
-- Minimal: UI + Silent Aim only (ยิงทะลุผนังแล้ว)

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

-- Basic refs
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- WindUI (same loader as original; if unavailable uses simple fallback)
local WindUI = nil
pcall(function()
    local Version = "1.6.53"
    WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/download/" .. Version .. "/main.lua"))()
end)

local Window
if WindUI then
    Window = WindUI:CreateWindow({
        Title = "MOKUN NEXUS - Aimbot",
        Icon = "crosshair",
        Author = "auto",
        Folder = "MOKUN_NEXUS_AIM",
        Size = UDim2.fromOffset(400, 220),
        Theme = "Dark",
        Transparent = true,
        Resizable = true,
        KeyCode = Enum.KeyCode.G
    })
else
    -- minimal fallback so later code can call Window:Tab
    Window = {
        Tab = function() return {
            Section = function() end,
            Toggle = function() return { Set = function() end } end,
            Slider = function() return { Set = function() end } end,
            Button = function() end,
            Input = function() return {} end,
            Divider = function() end
        } end
    }
end

local ConfigManager = Window.ConfigManager
local myConfig = ConfigManager and ConfigManager:CreateConfig and ConfigManager:CreateConfig("AimbotConfig") or { Register = function() end }

-- Aimbot settings
local SilentAimEnabled = false
local SilentAimAttachEnabled = false
local FOVRadius = 120
local CurrentTarget = nil

-- Drawing objects for FOV + Tracer
local SilentFOVCircle = nil
local Tracer = nil
pcall(function()
    if Drawing then
        SilentFOVCircle = Drawing.new("Circle")
        SilentFOVCircle.Color = Color3.fromRGB(255, 255, 255)
        SilentFOVCircle.Thickness = 2
        SilentFOVCircle.NumSides = 64
        SilentFOVCircle.Filled = false
        SilentFOVCircle.Transparency = 0.8
        SilentFOVCircle.Radius = FOVRadius
        SilentFOVCircle.Visible = false

        Tracer = Drawing.new("Line")
        Tracer.Thickness = 1
        Tracer.Color = Color3.fromRGB(255, 50, 50)
        Tracer.Transparency = 1
        Tracer.Visible = false
    end
end)

-- Utility
local function getPing()
    local ok, stats = pcall(function()
        return LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("NetworkStats")
    end)
    if ok and stats then
        local pingLabel = stats:FindFirstChild("PingLabel")
        if pingLabel and typeof(pingLabel.Text) == "string" then
            local n = tonumber(pingLabel.Text:match("%d+"))
            if n then return n / 1000 end
        end
    end
    return 0.20
end

local function predictPosition(head, hrp)
    local ping = getPing()
    local vel = hrp and hrp.Velocity or Vector3.zero
    return head.Position + (vel * math.clamp(ping * 1.15, 0, 1.5))
end

-- (ฟังก์ชัน isBehindWall ยังเก็บไว้แต่ตอนนี้ไม่ได้ใช้สำหรับบล็อกการยิง)
local function isBehindWall(startPos, endPos)
    if not startPos or not endPos then return false end
    local dir = endPos - startPos
    local ray = Ray.new(startPos, dir.Unit * math.min(dir.Magnitude, 1000))
    local ignoreList = {}
    if LocalPlayer.Character then table.insert(ignoreList, LocalPlayer.Character) end
    if CurrentTarget and CurrentTarget.Character then table.insert(ignoreList, CurrentTarget.Character) end
    local hit = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    return hit ~= nil
end

local function getClosestTarget()
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local best = nil
    local bestMag = FOVRadius
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local head = p.Character:FindFirstChild("Head")
            local hum = p.Character:FindFirstChild("Humanoid")
            local hrp = p.Character:FindFirstChild("HumanoidRootPart")
            if head and hum and hum.Health > 0 and hrp then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local sv = Vector2.new(screenPos.X, screenPos.Y)
                    local mag = (sv - center).Magnitude
                    if mag <= FOVRadius and mag < bestMag then
                        bestMag = mag
                        best = p
                    end
                end
            end
        end
    end
    return best
end

-- Remote hook (single)
local successRemote, RemotesFolder = pcall(function() return ReplicatedStorage:WaitForChild("Remotes", 5) end)
local SendRemote = successRemote and RemotesFolder and RemotesFolder:FindFirstChild("Send")

local oldFire = nil
if SendRemote and SendRemote.FireServer then
    local ok, hf = pcall(function()
        return hookfunction(SendRemote.FireServer, function(self, ...)
            if self ~= SendRemote then return hf(self, ...) end
            local args = {...}
            -- args[2] == "shoot_gun" per original logic
            if SilentAimEnabled and args[2] == "shoot_gun" then
                CurrentTarget = getClosestTarget()
                if CurrentTarget and CurrentTarget.Character then
                    local head = CurrentTarget.Character:FindFirstChild("Head")
                    local hrp = CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
                    local hum = CurrentTarget.Character:FindFirstChild("Humanoid")
                    local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
                    if head and hrp and hum and hum.Health > 0 and myHead then
                        local aimPos = predictPosition(head, hrp)
                        local myPos = myHead.Position

                        -- **แก้ตรงนี้: ยิงทะลุผนัง**
                        -- เดิมถ้าติดผนังจะตั้งเป็น miss (math.huge). ตอนนี้เราตั้งให้เล็งหัวเสมอ (ทะลุ)
                        args[4] = CFrame.new(myPos, aimPos)
                        -- payload: single-hit to head
                        args[5] = {
                            {
                                Instance = head,
                                Normal = Vector3.new(0, 1, 0),
                                Position = aimPos
                            }
                        }
                    end
                end
            end
            return hf(self, unpack(args))
        end)
    end)
    if ok then
        oldFire = hf
    else
        warn("Failed to hook Send Remote")
    end
end

-- UI (use WindUI from earlier script)
local Tab = Window:Tab({Title = "AIMBOT", Icon = "crosshair"})
Tab:Section({Title = "AIMBOT:"})

local SilentToggle = Tab:Toggle({
    Title = "Silent Aim",
    Default = SilentAimEnabled,
    Callback = function(state)
        SilentAimEnabled = state
        if SilentFOVCircle then SilentFOVCircle.Visible = state end
    end
})
if myConfig and myConfig.Register then myConfig:Register("SilentAim", SilentToggle) end

local AttachToggle = Tab:Toggle({
    Title = "Silent Aim (Attach)",
    Default = SilentAimAttachEnabled,
    Callback = function(state)
        SilentAimAttachEnabled = state
        if state then SilentAimEnabled = false SilentToggle:Set(false) end
    end
})
if myConfig and myConfig.Register then myConfig:Register("SilentAimAttach", AttachToggle) end

local FOVSlider = Tab:Slider({
    Title = "FOV",
    Step = 1,
    Value = { Min = 20, Max = 750, Default = FOVRadius },
    Callback = function(value)
        FOVRadius = tonumber(value) or FOVRadius
        if SilentFOVCircle then SilentFOVCircle.Radius = FOVRadius end
    end
})
if myConfig and myConfig.Register then myConfig:Register("FOVRadius", FOVSlider) end

-- Update loop: draw FOV circle + tracer, update CurrentTarget when attach enabled
RunService.RenderStepped:Connect(function()
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    -- handle attach mode: keep target updated
    if SilentAimAttachEnabled then
        CurrentTarget = getClosestTarget()
    end

    -- Drawing FOV circle in screen center
    if SilentFOVCircle then
        SilentFOVCircle.Visible = SilentAimEnabled or SilentAimAttachEnabled
        SilentFOVCircle.Position = centerScreen
        SilentFOVCircle.Radius = FOVRadius
    end

    -- Tracer: from center to target head on screen
    if Tracer then
        if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head") then
            local headPos = CurrentTarget.Character.Head.Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
            if onScreen then
                Tracer.Visible = true
                Tracer.From = centerScreen
                Tracer.To = Vector2.new(screenPos.X, screenPos.Y)
            else
                Tracer.Visible = false
            end
        else
            Tracer.Visible = false
        end
    end
end)

-- keep CurrentTarget updated per frame if normal SilentAim (non-attach) enabled
RunService.RenderStepped:Connect(function()
    if SilentAimEnabled and not SilentAimAttachEnabled then
        CurrentTarget = getClosestTarget()
    end
end)

-- keybind: toggle UI with G (if WindUI supports it)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.G and WindUI and Window then
        if Window.Toggle then
            Window:Toggle()
        elseif Window.SetVisible then
            Window:SetVisible(not Window.Visible)
        end
    end
end)
