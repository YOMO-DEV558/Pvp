-- =========================
-- Services
-- =========================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

-- =========================
-- Local Player & Camera
-- =========================
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- =========================
-- WindUI
-- =========================
local WindUI = nil
pcall(function()
    local Version = "1.6.53"
    WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/download/" .. Version .. "/main.lua"))()
end)

local Window
if WindUI then
    Window = WindUI:CreateWindow({
        Title = "MOKUN NEXUS üî´ | Silent Aim",
        Icon = "crosshair",
        Author = "UI Integration",
        Folder = "MOKUN_AIMBOT",
        Size = UDim2.fromOffset(400, 200),
        Theme = "Dark",
        Transparent = true,
        Resizable = true,
        KeyCode = Enum.KeyCode.G
    })
else
    Window = {
        Tab = function(_)
            return {
                Section = function() end,
                Toggle = function() return { Set = function() end } end,
                Slider = function() return { Set = function() end } end
            }
        end
    }
end

local ConfigManager = Window.ConfigManager
local myConfig = ConfigManager and ConfigManager:CreateConfig and ConfigManager:CreateConfig("SilentAimConfig") or {Register=function()end}

-- =========================
-- Silent Aim Core
-- =========================
local SilentAimEnabled = false
local WallCheckEnabled = true
local FOVRadius = 120
local CurrentTarget = nil

-- FOV Circle
local SilentFOVCircle = Drawing.new("Circle")
SilentFOVCircle.Color = Color3.fromRGB(255, 255, 255)
SilentFOVCircle.Thickness = 2
SilentFOVCircle.NumSides = 64
SilentFOVCircle.Filled = false
SilentFOVCircle.Transparency = 0.8
SilentFOVCircle.Radius = FOVRadius
SilentFOVCircle.Visible = false

-- Tracer
local Tracer = Drawing.new("Line")
Tracer.Thickness = 1
Tracer.Color = Color3.fromRGB(255, 50, 50)
Tracer.Transparency = 1
Tracer.Visible = false

-- Target Circle (‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏£‡∏≠‡∏ö‡∏´‡∏±‡∏ß‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢)
local TargetCircle = Drawing.new("Circle")
TargetCircle.Color = Color3.fromRGB(0, 255, 0)
TargetCircle.Thickness = 2
TargetCircle.NumSides = 64
TargetCircle.Filled = false
TargetCircle.Transparency = 1
TargetCircle.Radius = 15
TargetCircle.Visible = false

-- Utils
local function getPing()
    return 0.20
end

local function predictPosition(head, hrp)
    local ping = getPing()
    local vel = hrp and hrp.Velocity or Vector3.zero
    return head.Position + (vel * ping * 1.15)
end

local function isBehindWall(startPos, endPos)
    if not startPos or not endPos then return false end
    local ray = Ray.new(startPos, endPos - startPos)
    local ignoreList = {}
    if LocalPlayer.Character then table.insert(ignoreList, LocalPlayer.Character) end
    if CurrentTarget and CurrentTarget.Character then table.insert(ignoreList, CurrentTarget.Character) end
    local hit = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    return hit ~= nil
end

local function getClosestTarget()
    local best, bestDist = nil, FOVRadius
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _,p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character then
            local head = p.Character:FindFirstChild("Head")
            local hum = p.Character:FindFirstChild("Humanoid")
            local hrp = p.Character:FindFirstChild("HumanoidRootPart")
            if head and hum and hum.Health > 0 and hrp then
                local screenPos,onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X,screenPos.Y)-center).Magnitude
                    if dist <= FOVRadius and dist < bestDist then
                        bestDist = dist
                        best = p
                    end
                end
            end
        end
    end
    return best
end

-- Detect if gun is shotgun
local function isShotgun(toolName)
    toolName = toolName:lower()
    return toolName:find("shotgun") or toolName:find("pump") or toolName:find("sg")
end

-- Remote hook
local Remote = Remotes:FindFirstChild("Send")
if Remote and Remote.FireServer then
    local oldFire
    oldFire = hookfunction(Remote.FireServer, function(self,...)
        local args = {...}
        if SilentAimEnabled and args[2]=="shoot_gun" then
            CurrentTarget = getClosestTarget()
            if CurrentTarget and CurrentTarget.Character then
                local head = CurrentTarget.Character:FindFirstChild("Head")
                local hrp = CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
                local hum = CurrentTarget.Character:FindFirstChild("Humanoid")
                local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
                local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA("Tool")

                if head and hrp and hum and hum.Health>0 and myHead then
                    local aimPos = predictPosition(head, hrp)
                    local myPos = myHead.Position
                    local blocked = WallCheckEnabled and isBehindWall(myPos, aimPos)

                    if blocked then
                        if tool and isShotgun(tool.Name) then
                            args[4] = CFrame.new(math.huge, math.huge, math.huge) -- ‡∏ã‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏Å‡∏≥‡πÅ‡∏û‡∏á ‡∏¢‡∏¥‡∏á‡∏ß‡πà‡∏≤‡∏á
                        else
                            args[4] = CFrame.new(myPos, aimPos) -- ‡∏õ‡∏∑‡∏ô‡∏≠‡∏∑‡πà‡∏ô ‡∏¢‡∏¥‡∏á‡∏ó‡∏∞‡∏•‡∏∏
                            args[5] = {{
                                Instance=head,
                                Normal=Vector3.new(0,1,0),
                                Position=aimPos
                            }}
                        end
                    else
                        args[4] = CFrame.new(myPos, aimPos) -- ‡∏¢‡∏¥‡∏á‡∏ï‡∏£‡∏á‡∏´‡∏±‡∏ß
                        args[5] = {{
                            Instance=head,
                            Normal=Vector3.new(0,1,0),
                            Position=aimPos
                        }}
                    end
                end
            end
        end
        return oldFire(self, unpack(args))
    end)
end

-- =========================
-- UI Tabs
-- =========================
local Tab = Window:Tab({Title="AIMBOT", Icon="crosshair"})
Tab:Section({Title="Silent Aim"})

local Toggle = Tab:Toggle({
    Title = "Silent Aim",
    Default = SilentAimEnabled,
    Callback = function(state)
        SilentAimEnabled = state
        SilentFOVCircle.Visible = state
    end
})
myConfig:Register("SilentAim", Toggle)

local WallToggle = Tab:Toggle({
    Title = "Wall Check",
    Default = WallCheckEnabled,
    Callback = function(state)
        WallCheckEnabled = state
    end
})
myConfig:Register("WallCheck", WallToggle)

local FOVSlider = Tab:Slider({
    Title = "FOV",
    Step = 1,
    Value = {Min=20, Max=750, Default=FOVRadius},
    Callback = function(val)
        FOVRadius = val
        SilentFOVCircle.Radius = val
    end
})
myConfig:Register("FOVRadius", FOVSlider)

-- =========================
-- Render Loop
-- =========================
RunService.RenderStepped:Connect(function()
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    SilentFOVCircle.Position = center

    if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head") then
        local head = CurrentTarget.Character.Head
        local pos, onScreen = Camera:WorldToViewportPoint(head.Position)
        if onScreen then
            -- Tracer
            Tracer.Visible = true
            Tracer.From = center
            Tracer.To = Vector2.new(pos.X,pos.Y)
            -- Target circle
            TargetCircle.Visible = true
            TargetCircle.Position = Vector2.new(pos.X,pos.Y)
        else
            Tracer.Visible = false
            TargetCircle.Visible = false
        end
    else
        Tracer.Visible = false
        TargetCircle.Visible = false
    end

    if SilentAimEnabled then
        CurrentTarget = getClosestTarget()
    end
end)
